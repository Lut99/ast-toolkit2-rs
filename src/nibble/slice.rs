//  MOD.rs
//    by Lut99
//
//  Description:
//!   Implements the main input type, the [`Slice`].
//

use std::fmt::{Debug, Formatter, Result as FResult};
use std::hash::{DefaultHasher, Hash, Hasher};
use std::ops::{Deref, RangeFrom};

use super::{NibbleError, Parsable};
use crate::loc::Loc;


/***** LIBRARY *****/
/// The main input type to the nibble parser, which wraps around slices.
///
/// The idea is that every next parse step
/// equals "popping" the head off the slice. This gives you very precise control about when to
/// "peek" or when to "parse".
///
/// The alternative to slice-based parsing is to use some iterator abstraction. The advantage is
/// that you can use e.g. files as backing store for the iterator, which sounds appealing; but
/// there are a couple of downsides to that:
/// 1. Since files are fallible, the trait starts to require a lot of error management that's just
///    non-trivial enough to be annoying and greatly reduces the ergonomics of using the parser;
/// 2. Relying on a shared handle as we clone the parser object around is quite expensive
///    clone-wise, but the alternative (mutable references) is even worse and branching becomes
///    very complex; and
/// 3. The file needs to do some complex buffering to be robust and only load the part that we're
///    actively parsing in. If it assume it can load the entire file in once, we might as well load
///    it first and then parse the byte slice (which we're doing now).
///
/// Instead, the main use-case for using files as backing store is to not have to load the entire
/// file in memory. This library solves that by telling you if more input might have caused a
/// branch to be missed in [`NibbleError::Unmatched`], allowing you to progressively parse chunks
/// of your file until you have enough to parse what you want. This works great for e.g. statement
/// languages; you can use that to parse the input statement-by-statement. Essentially, this
/// externalizes the buffering logic to keep the parsing itself much simpler.
pub struct Slice<'a, T> {
    /// The actual slice wrapper.
    slice:  &'a [T],
    /// The offset that this slice points to. Goes in elements.
    offset: usize,
    /// Any ID to set in [`Loc`]s.
    id:     u64,
}

// Constructors
impl<'a, T> Slice<'a, T> {
    /// Constructor for the slice that builds it given the given slice.
    ///
    /// This will assign an ID that is the pointer of the given slice to any [`Loc`] that it
    /// generates. Use [`Slice::with_id()`] instead to give your own.
    ///
    /// # Arguments
    /// - `slice`: Some [`&[T]`](std::slice) to wrap.
    ///
    /// # Returns
    /// A new Slice that can be used for parsing.
    #[inline]
    pub fn new(slice: &'a [T]) -> Self { Self { slice, offset: 0, id: slice.as_ptr() as u64 } }

    /// Constructor for the slice that builds it given the given slice and [`Loc`] ID.
    ///
    /// This allows you to specify the ID set to any [`Loc`] generated by this slice.
    ///
    /// # Arguments
    /// - `id`: Some [`Hash`]able identifier that uniquely identifies this source. The hash is
    ///   stored in the [`Loc`]s. Note that the hash is created with a [`DefaultHasher`], implying
    ///   that you can use another one created with [`DefaultHasher::new()`] to get the same hash
    ///   later.
    /// - `slice`: Some [`&[T]`](std::slice) to wrap.
    ///
    /// # Returns
    /// A new Slice that can be used for parsing.
    #[inline]
    pub fn with_id(id: impl Hash, slice: &'a [T]) -> Self {
        Self {
            slice,
            offset: 0,
            id: {
                let mut hasher = DefaultHasher::new();
                id.hash(&mut hasher);
                hasher.finish()
            },
        }
    }

    /// Constructor for the slice that builds it with the given slice and [`Loc`] ID.
    ///
    /// Unlike [`Slice::with_id()`], this one does not run the hash function for you but instead
    /// asks you directly for the ID.
    ///
    /// # Arguments
    /// - `id`: The identifier that uniquely defines this source.
    /// - `slice`: Some [`&[T]`](std::slice) to wrap.
    ///
    /// # Returns
    /// A new Slice that can be used for parsing.
    #[inline]
    pub const fn with_raw_id(id: u64, slice: &'a [T]) -> Self { Self { slice, offset: 0, id } }
}

// Ops
impl<'a, T> Copy for Slice<'a, T> {}
impl<'a, T> Clone for Slice<'a, T> {
    #[inline]
    fn clone(&self) -> Self { Self { slice: self.slice, offset: self.offset, id: self.id } }
}
impl<'a, T> Debug for Slice<'a, T> {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> FResult {
        let mut fmt = f.debug_struct("Slice");
        fmt.field("id", &self.id);
        fmt.field("range", &(self.offset..));
        fmt.finish()
    }
}
impl<'a, T: Eq> Eq for Slice<'a, T> {}
impl<'a, T: Hash> Hash for Slice<'a, T> {
    /// NOTE: Hashing also includes the internal ID.
    #[inline]
    fn hash<H: Hasher>(&self, state: &mut H) {
        let Self { slice, offset, id } = self;
        id.hash(state);
        slice[*offset..].hash(state);
    }
}
impl<'a, T: PartialEq> PartialEq for Slice<'a, T> {
    /// NOTE: Equality for slices among themselves doesn't just check the contents, it also checks
    /// the source!
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        let Self { slice, offset, id } = self;
        id == &other.id && slice[*offset..] == other.slice[other.offset..]
    }
}
impl<'a, T: PartialEq<T2>, T2> PartialEq<[T2]> for Slice<'a, T> {
    #[inline]
    fn eq(&self, other: &[T2]) -> bool {
        let Self { slice, offset, id: _ } = self;
        &slice[*offset..] == other
    }
}
impl<'a, 'b, T2, T> PartialEq<&'a T2> for Slice<'a, T>
where
    T2: ?Sized,
    Slice<'a, T>: PartialEq<T2>,
{
    #[inline]
    fn eq(&self, other: &&'a T2) -> bool { <Self as PartialEq<T2>>::eq(self, other) }
}

// Parsing
impl<'a, T: Clone> Slice<'a, T> {
    /// Returns the head of this slice separately and a new Slice encoding the rest.
    ///
    /// If your type doesn't implement [`Clone`] or not cheaply, refer to [`Slice::head_ref()`]
    /// instead.
    ///
    /// # Returns
    /// A tuple of the head element (by reference) and then the rest of the slice. If this slice is
    /// empty, then so is the head.
    #[inline]
    pub fn head(self) -> (Option<T>, Self) {
        let (elem, rem) = self.head_ref();
        (elem.cloned(), rem)
    }

    /// Returns the head of this slice separately and a new Slice encoding the rest.
    ///
    /// If your type doesn't implement [`Clone`] or not cheaply, refer to [`Slice::head_ref_loc()`]
    /// instead.
    ///
    /// This overload returns a [`Loc`] to describe where in the slice this element came from. Use
    /// [`Slice::head()`] if you don't care.
    ///
    /// # Returns
    /// A tuple of the head element (by reference) and then the rest of the slice. If this slice is
    /// empty, then so is the head.
    #[inline]
    pub fn head_loc(self) -> (Option<(T, Loc)>, Self) {
        let (elem, rem) = self.head_ref_loc();
        (elem.map(|(elem, loc)| (elem.clone(), loc)), rem)
    }
}
impl<'a, T> Slice<'a, T> {
    /// Slices this slice into a subslice.
    ///
    /// Note that you can only slice at the _head_ of the slice.
    ///
    /// # Arguments
    /// - `range`: A [`RangeFrom`] deciding from where to slice onwards.
    ///
    /// # Returns
    /// A new [`Slice`] that a subset of this slice.
    #[inline]
    pub const fn slice(self, range: RangeFrom<usize>) -> Self { Self { slice: self.slice, offset: self.offset + range.start, id: self.id } }

    /// Returns the head of this slice separately and a new Slice encoding the rest.
    ///
    /// If you prefer to get the head element by value instead of reference, see [`Slice::head()`]
    /// instead.
    ///
    /// # Returns
    /// A tuple of the head element (by reference) and then the rest of the slice. If this slice is
    /// empty, then so is the head.
    #[inline]
    pub fn head_ref(self) -> (Option<&'a T>, Self) {
        let (elem, rem) = self.head_ref_loc();
        (elem.map(|(elem, _)| elem), rem)
    }

    /// Returns the head of this slice separately and a new Slice encoding the rest.
    ///
    /// If you prefer to get the head element by value instead of reference, see [`Slice::head_loc()`]
    /// instead.
    ///
    /// This overload returns a [`Loc`] to describe where in the slice this element came from. Use
    /// [`Slice::head_ref()`] if you don't care.
    ///
    /// # Returns
    /// A tuple of the head element (by reference) and then the rest of the slice. If this slice is
    /// empty, then so is the head.
    #[inline]
    pub fn head_ref_loc(self) -> (Option<(&'a T, Loc)>, Self) {
        let Self { slice, offset, id } = self;
        if let [head, ..] = &slice[offset..] {
            (Some((head, Loc::encapsulate_range(id, offset..=offset))), Self { slice, offset: offset + 1, id })
        } else {
            (None, self)
        }
    }

    /// Slices this Slice in half.
    ///
    /// # Arguments
    /// - `pos`: The point to slice. Think of this as the length of the left slice; i.e., the index
    ///   of the first element that will be in the right slice.
    ///
    /// # Returns
    /// A tuple with the first half of the slice and then the second. If the `pos` is beyond the
    /// number of elements in the slice, then the first slice is truncated and the second one is
    /// empty.
    #[inline]
    pub fn head_slice(self, pos: usize) -> (&'a [T], Self) {
        let Self { slice, offset, id } = self;
        if offset + pos <= slice.len() {
            (&slice[offset..offset + pos], Self { slice, offset: offset + pos, id })
        } else {
            (&slice[offset..], Self { slice, offset: slice.len(), id })
        }
    }

    /// Slices this Slice into multiple head elements and then the remainder slice.
    ///
    /// This overload returns a [`Loc`] to describe where in the slice the elements came from. Use
    /// [`Slice::head_slice()`] if you don't care.
    ///
    /// # Arguments
    /// - `pos`: The point to slice. Think of this as the length of the left slice; i.e., the index
    ///   of the first element that will be in the right slice.
    ///
    /// # Returns
    /// A tuple with the first half of the slice and then the second. If the `pos` is beyond the
    /// number of elements in the slice, then the first slice is truncated and the second one is
    /// empty.
    #[inline]
    pub fn head_slice_loc(self, pos: usize) -> ((&'a [T], Loc), Self) {
        let Self { slice, offset, id } = self;
        if offset + pos <= slice.len() {
            ((&slice[offset..offset + pos], Loc::encapsulate_range(id, offset..offset + pos)), Self { slice, offset: offset + pos, id })
        } else {
            ((&slice[offset..], Loc::encapsulate_range(id, offset..slice.len())), Self { slice, offset: slice.len(), id })
        }
    }

    /// Parses a full type from the head off the slice, returning the remainder.
    ///
    /// This function conveniently reverses the order on calling [`Parsable::parse()`].
    ///
    /// # Returns
    /// A tuple with the parsed element (if any) and then the remaining slice.
    #[inline]
    pub fn parse<T2: Parsable<T>>(self) -> Result<(T2, Self), NibbleError<T2::Formatter, T2::Error>> { T2::parse(self) }
}

// Deref
impl<'a, T> Slice<'a, T> {
    /// Returns the inner slice in this Slice.
    #[inline]
    pub fn as_slice(&self) -> &'a [T] { &self.slice[self.offset..] }
}
impl<'a, T> Deref for Slice<'a, T> {
    type Target = [T];

    #[inline]
    fn deref(&self) -> &Self::Target { &self.slice[self.offset..] }
}

// Conversion
impl<'a, T> AsRef<[T]> for Slice<'a, T> {
    #[inline]
    fn as_ref(&self) -> &[T] { &self.slice[self.offset..] }
}
impl<'a, T> From<&'a [T]> for Slice<'a, T> {
    #[inline]
    fn from(value: &'a [T]) -> Self { Self::new(value) }
}
impl<'a, T> From<Slice<'a, T>> for &'a [T] {
    #[inline]
    fn from(value: Slice<'a, T>) -> Self { &value.slice[value.offset..] }
}
impl<'a, const LEN: usize, T> From<&'a [T; LEN]> for Slice<'a, T> {
    #[inline]
    fn from(value: &'a [T; LEN]) -> Self { Self::new(value) }
}
impl<'a, const LEN: usize> TryFrom<Slice<'a, u8>> for [u8; LEN] {
    type Error = std::array::TryFromSliceError;

    #[inline]
    fn try_from(value: Slice<'a, u8>) -> Result<Self, Self::Error> { value.as_slice().try_into() }
}
impl<'a> From<&'a str> for Slice<'a, u8> {
    #[inline]
    fn from(value: &'a str) -> Self { Self::new(value.as_bytes()) }
}
impl<'a> TryFrom<Slice<'a, u8>> for &'a str {
    type Error = std::str::Utf8Error;

    #[inline]
    fn try_from(value: Slice<'a, u8>) -> Result<Self, Self::Error> { std::str::from_utf8(value.as_slice()) }
}
